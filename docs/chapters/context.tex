\chapter{Context}\label{ch:context}

\section{Voting systems}\label{sec:voting-systems}

\section{Blockchain}\label{sec:blockchain}

Even though the first blockchain-like protocol was proposed by \textcite{chaum_computer_1982}, the concept of modern \gls{Blockchain} technology was first introduced in 2008 by \textcite{nakamoto_bitcoin_2008} and with the subsequent launch of Bitcoin in 2009.
Although Satoshi Nakamoto's real identity remains a mistery to this day, he alluded to his motivations with a message left in Bitcoin's \gls{GenesisBlock}.
It reads \enquote{The Times 03/Jan/2009 Chancellor on brink of second bailout for banks} and is a reference to the headline of an article that appeared in \emph{The Times} on January 3, 2009 in the midst of the \gls{GFC}.

A \gls{Blockchain} is a distributed ledger, meaning a decentrally updated data structure maintained by a \gls{P2P} network~\autocites[3]{crosby_blockchain_2015}[1]{nakamoto_bitcoin_2008}.
\Gls{Blockchain} protocols secure data immutability in a trustless network without the need for a central authority~\autocites[3]{crosby_blockchain_2015}[4]{jafar_blockchain_2021}.
These protocols reward nodes, also called miners, for validating and adding new data to the \gls{Blockchain} in the form of blocks that consist of bundled transactions propagated to the network by its users.
More specifically, when a sender initiates a transaction, he first signs it, then all nodes in the network receive the transaction and add it to their local blocks.
However, before they are permitted to add their block to the \gls{Blockchain}, they have to solve a hash calculation looking for a hashed output that begins with a number of zero bits (see~\cref{subsec:pow}).
This operation is called \gls{POW}, as it requires energy in the form of computing power~\autocite[3]{nakamoto_bitcoin_2008}.

\subsection{Blocks}\label{subsec:blocks}

As mentioned above, the \gls{Blockchain} consists of data blocks linked to each other in a chain.
The end of the chain is the most recently mined block, so following the chain back to its start essentially means following the entire transaction history of the \gls{Blockchain} back to its first transaction in the second block.
The first block of the chain is the \gls{GenesisBlock}, which contains no transaction data as it initiates the \gls{Blockchain} when the network is deployed~\autocites[162]{antonopoulos_mastering_2017}[31]{antonopoulos_mastering_2019}.

\subsubsection{Block structure}\label{subsubsec:block-structure}

Depending on the \gls{Blockchain}, block structures might vary, though, according to~\textcite[15-16]{yaga_blockchain_2018}, the structure shown in~\cref{tab:block-structure} represents a commonly implemented data field.

\begin{table}[H]
    \begin{tabularx}{\textwidth}{ssb}
        \hline
        \textbf{Size} & \textbf{Field} & \textbf{Description} \\
        4 bytes & Block size & The block's size in bytes excluding this field \\
        \hline
        80 bytes & Block header & Metadata \\
        \hline
        1-9 bytes & Transaction counter & Number of transactions in the block \\
        \hline
        Variable & Transactions & The transactions submitted with this block \\
        \hline
    \end{tabularx}
    \caption[Block structure]{Block structure. Please note that block sizes may also vary between different \glspl{Blockchain}. Based on \textcite[160]{antonopoulos_mastering_2017}}
    \label{tab:block-structure}
\end{table}

\subsubsection{Block header}\label{subsubsec:block-header}

The block header contains metadata about the block itself and a reference to the previous block hash (see~\cref{fig:prev-block-hash}), establishing a chain link~\autocites[160]{antonopoulos_mastering_2017}[3]{nakamoto_bitcoin_2008}[15]{yaga_blockchain_2018}.
Nodes always work on bundling transactions in a new block using the latest accepted block's hash value in the block header~\autocite[3]{nakamoto_bitcoin_2008}.
Aside from the previous block's hash value, a block header contains the current timestamp, \gls{POW} difficulty target for the current block and the nonce (see~\cref{subsec:hash-algorithms}), as well as the \gls{MerkleTree} root, a data structure summarizing all transactions in the block~\autocites[160-161]{antonopoulos_mastering_2017}[15-16]{yaga_blockchain_2018}.

\begin{figure}[h]
    \label{fig:prev-block-hash}
    \includegraphics{nakamoto-2008-blocks}
    \caption[Linked blocks]{Linked blocks~\autocite{nakamoto_bitcoin_2008}}
\end{figure}

As \textcite[2-3]{nakamoto_bitcoin_2008} states, the inclusion of the previous block hash and the timestamp in a block's header serve a security purpose where protection grows stronger with every subsequent block added to the chain.
This is because a bad actor propagating an altered block to the network cannot do so without changing its hashed value, which would also change the next block's value as it includes the hash of its predecessor.
Thus, an attacker would first have to change the target block and then redo the \gls{POW} for all blocks that followed while outrunning the mining efforts of every honest node in the network.

\subsection{Hash algorithms}\label{subsec:hash-algorithms}

In cryptography, hashing functions are used to calculate a relatively unique fixed-length deterministic output, also called digest, from an arbitrary-length input value, as stated by~\textcite[188]{antonopoulos_mastering_2017}.
The digest acts as a digital fingerprint of the given value, meaning that individuals can verify data with hash functions independently and would immediately recognize changes to already existing data since these would produce an entirely different digest when hashed~\autocites[188-189]{antonopoulos_mastering_2017}[7]{yaga_blockchain_2018}.

\subsubsection{SHA-256}
Many \glspl{Blockchain} utilize the \gls{SHA} hash function with an output of 256 bits.
SHA-256 outputs a 32-byte hexadecimal value equaling 256 bits.
Hence, SHA-256 can produce \begin{math}2\textsuperscript{256}\approx10\textsuperscript{77}\end{math} unique digest values.

\codeFromFile{python}{code_snippets/hash.py}{Simple example of a SHA-256 hashing script in Python}{Simple example of a SHA-256 hashing script in Python}{lst:simple-example-of-sha256}

The Python script displayed in listing~\ref{lst:simple-example-of-sha256} yields the below output where the prefix \emph{0x} indicates a binary sequence will follow:

\smallskip
\begingroup\small\emph{0x64ec88ca00b268e5ba1a35678a1b5316d212f4f366b2477232534a8aeca37f3c}\endgroup
\smallskip

Since SHA-256 can produce such a high number of unique digests, it is said to be collision-free, meaning it is improbable that two unique inputs will produce the same output~\autocite[8]{yaga_blockchain_2018}.

\subsection{Asymmetric key cryptography}\label{subsec:asymmetric-key-cryptography}

\Gls{Blockchain} technology relies on asymmetric key cryptography.
In asymmetric key cryptography two keys are used, the \gls{PK} and the \gls{PBK} (see~\cref{fig:asymmetric-key}).

\begin{figure}[H]
    \begin{subfigure}[b]{\textwidth}
        \centering
        \includegraphics[scale=0.4]{chandra-2014-symmetric_key}
        \caption{Symmetric key}
        \label{fig:symmetric-key}
    \end{subfigure}
    \begin{subfigure}[b]{\textwidth}
        \centering
        \includegraphics[scale=0.4]{chandra-2014-asymmetric_key}
        \caption{Asymmetric key}
        \label{fig:asymmetric-key}
    \end{subfigure}
    \caption[Cryptographic keys]{Cryptographic keys~\autocite[84]{chandra_comparative_2014}}\label{fig:cryptographic-keys}
\end{figure}

Contrary to symmetric key encryption shown in~\cref{fig:symmetric-key}, where both users possess the same key and are therefore required to trust each other, asymmetric key encryption demands no such trust~\autocites[84]{chandra_comparative_2014}[11]{yaga_blockchain_2018}.
This is a critical difference since users cannot trust nodes in the network and vice versa.
By employing a particular type of asymmetric key cryptography, called elliptic curve cryptography (see~\cref{subsec:elliptic-curve-cryptography}), \gls{Blockchain} users can prove ownership over funds via signing transactions with their \gls{PK} without the need to share it with untrusted third parties.
Meanwhile, nodes in the network can verify the alleged ownership using the \gls{PBK}.

\subsection{Elliptic curve cryptography}\label{subsec:elliptic-curve-cryptography}

\begin{figure}[H]
    \begin{center}
        \includegraphics{kapoor-2008-elliptic_curve}
    \end{center}
    \caption[Point addition on an elliptic curve]{Point addition on an elliptic curve~\autocite[5]{kapoor_elliptic_2008}}
    \label{fig:elliptic-curve}
\end{figure}

Elliptic curve cryptography is another approach to asymmetric key cryptography based on elliptic curves over finite fields.
It is based on the \emph{elliptic curve discrete logarithm} problem expressed by addition and multiplication on the curve's points~\autocites[65]{antonopoulos_mastering_2017}[5]{kapoor_elliptic_2008}.
The most crucial property of elliptic curves is that adding two points on the curve will yield a third point also located on the curve~\autocite[5]{kapoor_elliptic_2008}.
This addition can be described mathematically by

\begin{align}\label{eq:curve-addition}
    R(x_3,y_3)=P(x_1,y_1)+Q(x_2,y_2)
\end{align}

As shown in \cref{fig:elliptic-curve}, the third point is calculated geometrically by drawing a line between $P$ and $Q$, which intersects the curve at an additional point reflecting $R$ on the x-axis.

With a defined addition rule, curve multiplication can be applied with $kP$ where $k$ is a positive integer and $P$ a point on the curve as the sum of $k$ times $P$~\autocite[5]{kapoor_elliptic_2008}.

In consequence,~\textcites[65,68]{antonopoulos_mastering_2017}[5]{kapoor_elliptic_2008} state, that given an agreed-upon curve \emph{generator point} $P$ and a none-secret elliptic curve, one can select a secret random integer $k$ to derive a public curve point $K$ from it using elliptic curve multiplication

\begin{align}\label{eq:curve-multiplication}
    K=k \cdot P
\end{align}

\begin{figure}[H]
    \begin{center}
        \includegraphics[scale=0.3]{price-2020-inverse-curve-addition}
    \end{center}
    \caption[Finding point $P$ in $kP$ given $k=2$]{Finding point $P$ in $kP$ given $k=2$.
    Shows the possibility of multiple points whose tangent lines cross the negation of a given point~\autocite{price_bitcoins_2020}}
    \label{fig:finding-point-p}
\end{figure}

Reversing the multiplication process by solving for $k$ would be an unfeasible operation since the multiplication is nonlinear as the output point can be anywhere on the curve with respect to the input point~\autocite{price_bitcoins_2020}.
Furthermore, going backward, e.g., solving for $P$ provided $kP$, where $k$ is a random integer, is more difficult due to the symmetry of elliptic curves.
Meaning, there might exist multiple points $P$ whose tangent lines cross the negation of $kP$ for any number of additive iterations in the multiplication process (see \cref{fig:finding-point-p}).
Therefore, a sufficiently high curve order exponentially increases the computing power needed to solve for $k$, making $K$ sharable with untrusted third parties without having to sacrifice the privacy of $k$.

\subsubsection{Private key}\label{subsubsec:private-key}

The \gls{PK} or $k$ (see~\cref{fig:elliptic-curve-trapdoor}) is a 256-bit number picked at random when a user creates a new wallet address;
it can be any number between $1$ and $n-1$, where $n$ is a constant that defines the order of the elliptic curve $k$~\autocite[63]{antonopoulos_mastering_2017}.

\begin{figure}[H]
    \includegraphics[width=\textwidth]{cryptographic_trapdoor}
    \caption[Cryptographic trapdoor functions]{Cryptographic trapdoor functions. Shows the direction in which trapdoor functions are utilized to achieve a one-way relationship between \gls{PK}, \gls{PBK} and a wallet's address. Based on~\textcite[160]{antonopoulos_mastering_2017}}
    \label{fig:elliptic-curve-trapdoor}
\end{figure}

\subsubsection{Public key}\label{subsubsec:public-key}

As stated above, the \gls{PBK} is generated from the \gls{PK} with elliptic curve multiplication.
The relationship between the pair is fixed and can only be calculated in one direction (see \cref{fig:elliptic-curve-trapdoor}).


%\codeFromFile{python}{code_snippets/pow_hash.py}{Simplified proof-of-work implementation~\autocite[191-192]{antonopoulos_mastering_2017}}{Simplified proof-of-work implementation}{lst:simplified-proof-of-work}
%\codeFromFile{bash}{code_snippets/hash_output.sh}{Output of nonce iterating hashing script}{Output of nonce iterating hashing script}{lst:output-of-hashing-script}

\subsection{Proof-of-Work}\label{subsec:pow}

Nodes in the network are only allowed to add a new block to the chain when they have solved a computing problem, i.e., they have to provide \glsfirst{POW}.
In the case of Bitcoin, this problem involves scanning for a value whose hashed output begins with a number of zero bits by incrementing on a \gls{Nonce}~\autocite[3]{nakamoto_bitcoin_2008}.
Furthermore, since hashing algorithms are designed to (see \cref{subsec:hash-algorithms}) produce unique outputs for a given input, aside from trying random inputs, it is also impossible to produce the desired output from a selected input~\autocite[189]{antonopoulos_mastering_2017}.

\codeFromFile{python}{code_snippets/hash_nonce.py}{Iterating on a nonce. Based on~\textcite[189]{antonopoulos_mastering_2017}}{Iterating on a nonce}{lst:hashing-script-with-nonce}

Listing~\ref{lst:hashing-script-with-nonce} illustrates a simplified hashing function that will output different hashes by adding a \gls{Nonce} to the input value on each iteration.
For instance, if the difficulty target is given as

\smallskip
\begingroup\small\emph{0x0010000000000000000000000000000000000000000000000000000000000000}\endgroup
\smallskip

a smaller hash would need to start with three zero bits.
The winning \gls{Nonce} in this example would then be 11 (see listing~\ref{lst:output-of-hashing-script}).
Hence, the act of finding the winning \gls{Nonce} would be \gls{POW} equivalent to the computing power needed to run this script 12 times.

\codeFromFile{text}{code_snippets/hash_output.sh}{Output of nonce iterating hashing script}{Output of nonce iterating hashing script}{lst:output-of-hashing-script}

Clearly, \gls{POW} hashing algorithms employed by \gls{Blockchain} protocols are considerably more complex but in principle this is how they work.
Consequently, once a node has provided the \gls{POW} required by the network to add a new block to the chain an attacker would need to redo the work for that block and all blocks after it.

\section{Web3}\label{sec:web3}

\subsection{Ethereum}\label{subsec:ethereum}
\subsection{Smart contracts}\label{subsec:smart-contracts}
\subsection{DApps}\label{subsec:dapps}

\section{Development tools}\label{sec:development-tools}

\subsection{Node.js}\label{subsec:node.js}

Node.js is a JavaScript runtime environment that enables the execution of JavaScript code outside a web browser.

\subsection{NX Monorepo}\label{subsec:nx-monorepo}
\subsection{Next.js}\label{subsec:next.js}
\subsection{Nest.js}\label{subsec:nest.js}
\subsection{Prisma}\label{subsec:prisma}
\subsection{PostgresSQL}\label{subsec:postgressql}

\section{References}\label{sec:references}

